













# 一、小程序起步

# 1 、 小程序-起步

> 学习目标：
>
> 能够知道如何创建小程序项目
> 能够清楚小程序项目的基本组成结构
> 能够知道小程序页面由几部分组成
> 能够知道小程序中常见的组件如何使用
> 能够知道小程序如何进行协同开发和发布

## 1.1. 小程序简介

### 1.1.1 小程序与普通网页开发的区别

- 运行环境不同 

  - 网页运行在浏览器环境中 

  - 小程序运行在微信环境中

- API 不同

  由于运行环境的不同，所以小程序中，无法调用DOM 和BOM 的API。 但是，小程序中可以调用微信环境提供

  的各种API，例如： 

  - 地理定位 
  - 扫码 
  - 支付

- 开发模式不同

  网页的开发模式：浏览器+ 代码编辑器小程序有自己的一套标准开发模式： 

  - 申请小程序开发账号 
  - 安装小程序开发者工具 
  - 创建和配置小程序项目

### 1.1.2体验小程序 

可使用手机微信(6.7.2 及以上版本)扫码下方小程序码，体验小程序：

![](images\小程序起步\2022-03-02_105011.png)





## 1.2注册小程序开发帐号

### 1.2.1 点击注册按钮

​		使用浏览器打开https://mp.weixin.qq.com/网址，点击右上角的“立即注册”即可进入到小程序开发账号

的注册流程，主要流程截图如下：

![](images\小程序起步\2022-03-02_105258.png)

### 1.2.2选择注册账号的类型

![](images\小程序起步\2022-03-02_105405.png)

### 1.2.3填写账号信息

![](images\小程序起步\2022-03-02_105505.png)

### 1.2.4提示邮箱激活

![](images\小程序起步\2022-03-02_105850.png)

### 1.2.5点击链接激活账号

![](images\小程序起步\2022-03-02_110216.png)

### 1.2.6选择主体类型

![](images\小程序起步\2022-03-02_110310.png)

### 1.2.7主体信息登记

![](images\小程序起步\2022-03-02_110409.png)

### 1.2.8获取小程序的AppID

![](images\小程序起步\2022-03-02_110507.png)

## 1.3安装开发者工具

### 1.3.1了解微信开发者工具

微信开发者工具是官方推荐使用的小程序开发工具，它提供的主要功能如下：

①快速创建小程序项目 

②代码的查看和编辑 

③对小程序功能进行调试 

④小程序的预览和发布

### 1.3.2下载

推荐下载和安装最新的稳定版（Stable Build）的微信开发者工具，下载页面的链接如下：

https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html

![](images\小程序起步\2022-03-02_110750.png)

### 3.3.3安装

![](images\小程序起步\2022-03-02_112408.png)

**点击完成**

![](images\小程序起步\2022-03-02_112514.png)

### 3.3.4 扫码登录

![2022-03-02_113146](images\小程序起步\2022-03-02_113146.png)

![](images\小程序起步\2022-03-02_113318.png)

### 3.3.5设置外观和代理

![](images\小程序起步\2022-03-02_113614.png)

## 1.4创建小程序项目

### 1.4.1点击“加号”按钮

![](J:\学习笔记\study-notes\微信小程序\images\小程序起步\2022-03-02_113942.png)

### 1.4.2填写项目信息

![](images\小程序起步\2022-03-02_113743.png)

### 1.4.3项目创建完成

![](images\小程序起步\2022-03-02_114102.png)

### 1.4.4在模拟器上查看项目效果

![](images\小程序起步\2022-03-02_114232.png)

### 1.4.5在真机上预览项目效果

![](images\小程序起步\2022-03-02_114632.png)

### 1.4.6主界面的5 个组成部分

![](images\小程序起步\2022-03-02_114314.png)

# 2 、 项目结构

## 2.1了解项目的基本组成结构

![](images\小程序起步\2022-03-02_115450.png)

## 2.2 小程序页面的组成部分

**小程序官方建议把所有小程序的页面，都存放在pages 目录中，以单独的文件夹存在，如图所示：**

![](images\小程序起步\2022-03-02_115842.png)

## 2.3JSON 配置文件的作用

​	**JSON 是一种数据格式**，在实际开发中，**JSON 总是以配置文件的形式出现**。小程序项目中也不例外：通过不同

的.json 配置文件，可以对小程序项目进行不同级别的配置。 

小程序项目中有4 种json 配置文件，分别是： 

①项目根目录中的app.json 配置文件 

②项目根目录中的**project.config.json** 配置文件 

③项目根目录中的sitemap.json配置文件 

④每个页面文件夹中的**.json 配置文件**

### 2.3.1 app.json 文件 

​	app.json 是当前小程序的全局配置，包括了小程序的所有**页面路径、窗口外观、界面表现、底部tab 等**。

**Demo 项目里边的app.json 配置内容如下：**

```json
{
  "pages":[
    "pages/index/index",
    "pages/logs/logs"
  ],
  "window":{
    "backgroundTextStyle":"light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "Weixin",
    "navigationBarTextStyle":"black"
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json"
}
```

**简单了解下这4 个配置项的作用：** 

①**pages**：用来记录当前小程序所有页面的路径 

②**window**：全局定义小程序所有页面的背景色、文字颜色等

③**style**：全局定义小程序组件所使用的样式版本 

④sitemapLocation：用来指明sitemap.json的位置

### 2.3.2 **project.config.json 文件**

project.config.json 是项目配置文件，用来记录我们对小程序开发工具所做的个性化配置，例如： 

- setting 中保存了编译相关的配置 
-  projectname 中保存的是项目名称 
- appid 中保存的是小程序的账号 ID

### **2.3.4. sitemap.json 文件** 

​	微信现已开放**小程序内搜索**，效果类似于 PC 网页的 SEO。sitemap.json 文件用来配置小程序页面是否允许 

**微信索引**。 

​	当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索关键字和页 

面的索引匹配成功的时候，小程序的页面将可能展示在搜索结果中。 **（如果讲 "action": "disallow",页面将不会被索引）**

![](images\小程序起步\2022-03-02_142250.png)

**注意：**sitemap 的索引提示是默认开启的，如需要关闭 sitemap 的索引提示，可在小程序项目配置文件 

**project.config.json 的 setting** 中配置字段 **checkSiteMap 为 false**

![](images\小程序起步\2022-03-02_142357.png)

### **2.3.5页面的 .json 配置文件**

​	小程序中的每一个页面，可以使用 .json 文件来对本页面的窗口外观进行配置，**页面中的配置项会覆盖** 

**app.json 的 window 中相同的配置项**。例如：

![](images\小程序起步\2022-03-02_143423.png)

## 2.4新建小程序页面

​	只需要在**app.json -> pages**中**新增页面的存放路径**，小程序开发者工具即可帮我们自动创建对应的页面文件，

如图所示：

![](images\小程序起步\2022-03-02_143614.png)

## 2.5.修改项目首页

​	**只需要调整app.json -> pages数组中页面路径的前后顺序**，即可修改项目的首页。小程序会把排在第一位的页

面，当作项目首页进行渲染，如图所示：

![](images\小程序起步\2022-03-02_144201.png)

# 3、小程序代码的构成

## 3.1WXML 模板

#### 3.1.1什么是WXML

​	WXML（WeiXin Markup Language）是小程序框架设计的**一套标签语言，用来构建小程序页面的结构**，其作

用类似于网页开发中的HTML。

#### 3.1.2WXML 和HTML 的区别

​	**1.标签名称不同**

```html
HTML （div, span, img, a）
WXML（view, text, image, navigator）
```

​	**2.属性节点不同**

```
<a href="#">超链接</a>
<navigator url="/pages/home/home"></navigator>
```

​	**3.提供了类似于Vue 中的模板语法**

​		数据绑定、列表渲染、条件渲染

## 3.2WXSS 样式

#### 3.2.1什么是WXSS

​	WXSS (WeiXin Style Sheets)是一套样式语言，用于描述WXML 的组件样式，类似于网页开发中的CSS。

#### 3.2.2WXSS 和CSS 的区别

1. **新增了rpx 尺寸单位**

   - CSS 中需要手动进行像素单位换算，例如rem 

   - WXSS 在底层支持新的尺寸单位rpx，在不同大小的屏幕上小程序会自动进行换算

2. 提供了全局的样式和局部样式

   - 项目根目录中的app.wxss 会作用于所有小程序页面 

   - 局部页面的.wxss 样式仅对当前页面生效 

3. WXSS 仅支持部分CSS 选择器

   - class 和#id 
   - element 
   - 并集选择器、后代选择器 
   - ::after 和::before 等伪类选择器

#### 3.2.3JS 逻辑交互

1. **小程序中的.js 文件**

   一个项目仅仅提供界面展示是不够的，在小程序中，我们通过.js 文件来处理用户的操作。例如：响应用户的点击、获取用户的位置等等。

2. **JS 逻辑交互**

   - 小程序中.js 文件的分类	

     小程序中的JS 文件分为三大类，分别是：

     - **app.js**

       是整个小程序项目的入口文件，**通过调用App() 函数来启动整个小程序**

     - **页面的.js 文件**

       是页面的入口文件，**通过调用Page() 函数来创建并运行页面**

     - **普通的.js 文件**

       是普通的功能模块文件，**用来封装公共的函数或属性供页面使用**

   

   

# 4、小程序的宿主环境

## 4.1 什么是宿主环境

宿主环境（host environment）指的是程序运行所**必须的依赖环境**。例如： 

​	Android 系统和 iOS 系统是两个不同的宿主环境。安卓版的微信 App 是不能在 iOS 环境下运行的，所以Android 是安卓软件的宿主环境，脱离了宿主环境的软件是没有任何意义的！

![](images\小程序起步\2022-03-02_205847.png)

## 4.2小程序的宿主环境

​	**手机微信是小程序的宿主环境**，如图所示:

![](J:\学习笔记\study-notes\微信小程序\images\小程序起步\2022-03-02_210050.png)

​	小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能，例如：

- 微信扫码、微信支付、微信登录、地理定位、etc…

  

## 4.3小程序宿主环境包含的内容

1. 通信模型 
2. 运行机制 
3. 组件 
4. API

### 4.3.1通信的主体

小程序中通信的主体是渲染层和逻辑层，其中：

①WXML 模板和WXSS 样式工作在渲染层 

②JS 脚本工作在逻辑层

![](images\小程序起步\2022-03-02_210343.png)

### 4.3.2小程序的通信模型

小程序中的通信模型分为两部分：

①**渲染层**和**逻辑层**之间的通信

- 由微信客户端进行转发

②逻辑层和第三方服务器之间的通信

- 由微信客户端进行转发

![](images\小程序起步\2022-03-02_210543.png)

### 4.3.3小程序的运行机制

1. **小程序启动的过程**

   ①把小程序的代码包下载到本地 

   ②解析app.json 全局配置文件 

   ③执行app.js 小程序入口文件，**调用App() 创建小程序实例**

   ④渲染小程序首页 

   ⑤小程序启动完成

2. **页面渲染的过程**

   ①加载解析页面的.json 配置文件 

   ②加载页面的.wxml 模板和.wxss 样式 

   ③执行页面的.js 文件，调用Page() 创建页面实例

   ④页面渲染完成

   

## 4.4组件

### 4.4.1小程序中组件的分类

**小程序中的组件也是由宿主环境提供的**，开发者可以基于组件快速搭建出漂亮的页面结构。官方把小程序的组

件分为了9 大类，分别是： 

​	**①视图容器** 

​	**②基础内容** 

​	**③表单组件** 

​	**④导航组件** 

​	⑤媒体组件 

​	⑥map 地图组件 

​	⑦canvas 画布组件 

​	⑧开放能力 

​	⑨无障碍访问

### 4.4.2 常用的视图容器类组件

1. view
   - 普通视图区域 
   - 类似于HTML 中的div，是一个块级元素 
   - 常用来实现页面的布局效果
2. scroll-view
   - 可滚动的视图区域 
   - 常用来实现滚动列表效果
3. swiper 和swiper-item
   - 轮播图容器组件和轮播图item 组件

### 4.3.3view 组件的基本使用

**实现如图的flex 横向布局效果：**

![](images\小程序起步\2022-03-02_211759.png)

```CSS
<view class="tilte">view组件</view>
<view class="containerl">
  <view>你好</view>
  <view>微信</view>
  <view>小程序</view>
</view>

.tilte{
  width: 300px;
  height: 30px;
  margin: 20px auto 20px auto;
  text-align: center;
  font-size:20px;
  line-height: 30px;
  color: rgb(54, 48, 48);
  border: 1px solid rgba(119, 224, 145, 0.719);
  border-radius: 5px;
  
}
.tilte:hover{
  background-color: rgb(241, 181, 223);
  color: aliceblue;
  border: 1px solid rgba(69, 71, 70, 0.719);
}
.containerl{
  display: flex;
  justify-content: space-around;
}
.containerl view{
  width: 100px;
  height: 100px;
  text-align: center;
  line-height: 100px;
}
.containerl view:nth-child(1){
  background-color: lightblue;
}
.containerl view:nth-child(2){
  background-color: lightgreen;
}
.containerl view:nth-child(3){
  background-color: lightpink;
}
```

### 4.3.4scroll-view 组件的基本使用

**实现如图的纵向滚动效果：**

![](images\小程序起步\2022-03-02_212220.png)

```css
<view class="tilte">scroll-view组件</view>
<!--  
  scroll-y属性：向上下滚动
  scroll-x属性：向左右滚动
 -->
<scroll-view class="scrollBox" scroll-y>
  <view>你好</view>
  <view>微信</view>
  <view>小程序</view>
</scroll-view>

.scrollBox{
  text-align: center;
  margin: 0px auto;
  width: 300px;
  height: 200px;
}
.scrollBox view{
  width: 300px;
  height: 200px;
  text-align: center;
  line-height: 200px;
  font-size: 20px;
}
.scrollBox view:nth-child(1){
  background-color: lightblue;
}
.scrollBox view:nth-child(2){
  background-color: lightgreen;
}
.scrollBox view:nth-child(3){
  background-color: lightpink;
}
```

### 4.3.5swiper 和swiper-item 组件的基本使用

**实现如图的轮播图效果：**

![](images\小程序起步\2022-03-02_212538.png)

```css
<!-- 轮播图区域swiper属性
    indicator-doc:是否显示面板指示点
    indicator-color:指示点颜色
    indicator-active-color:当前选中指示点颜色
    autoplay:是否自动切换
    interval:自动切换时间间隔
    circular:是否采用衔接滑动
-->
<view class="tilte">swiper和swiper-item组件</view>
<swiper indicator-dots="true" indicator-color="#fff" indicator-active-color="#ccc" autoplay interval='2000' circular="true">
  <!-- 第一项 -->
  <swiper-item class="swriper-containter">
    <view class="items">你好</view>
  </swiper-item>
  <!-- 第二项 -->
  <swiper-item>
    <view class="items">微信</view>
  </swiper-item>
  <!-- 第三项 -->
  <swiper-item>
    <view class="items">小程序</view>
  </swiper-item>
</swiper>


.swriper-containter{
  height: 150px;
}
.items{
  height: 100%;
  font-size: 25px;
  line-height: 150px;
  text-align: center;
}
swiper-item:nth-child(1) .items{
  background-color: lightgreen;
}
swiper-item:nth-child(2) .items{
  background-color: lightskyblue;
}
swiper-item:nth-child(3) .items{
  background-color: lightblue;
}
```

### 4.3.6swiper 组件的常用属性

| 属性                   | 类型    | 默认值            | 说明                 |
| ---------------------- | ------- | ----------------- | -------------------- |
| indicator-dots         | boolean | FALSE             | 是否显示面板指示点   |
| indicator-color        | color   | rgba(0, 0, 0, .3) | 指示点颜色           |
| indicator-active-color | color   | #000000           | 当前选中的指示点颜色 |
| autoplay               | boolean | FALSE             | 是否自动切换         |
| interval               | number  | 5000              | 自动切换时间间隔     |
| circular               | boolean | FALSE             | 是否采用衔接滑动     |

### 4.3.7**常用的基础内容组件** 

1.  **text**
   - 文本组件 
   - 类似于 HTML 中的 span 标签，是一个行内元素 
2.  **rich-text** 
   - 富文本组件 
   -  支持把 HTML 字符串渲染为 WXML 结构



### 4.3.8.text 组件的基本使用

**通过 text 组件的 selectable 属性，实现长按选中文本内容的效果**

### 4.3.9rich-text 组件的基本使用

**通过 rich-text 组件的 nodes 属性节点，把 HTML 字符串渲染为对应的 UI 结构**

![](images\小程序起步\2022-03-02_214256.png)

```css
<!--text和rich-text组件
    selectable：通过 text 组件的 selectable 属性，实现长按选中文本内容的效果
    通过 rich-text 组件的 nodes 属性节点，把 HTML 字符串渲染为对应的 UI 结构
  -->
<view class="tilte">text和rich-text组件</view>
<view class="text-box">
  支持长按选中效果:
  <text selectable>你好，微信小程序！</text>
  <rich-text nodes="<h1 style='color:pink'>标题</h1>"></rich-text>
</view>

.text-box{
  padding-top: 20px;
  height: 100px;
  text-align: center;
  background-color:lightyellow;
}
```

## 4.6其它常用组件 

1.  button 
   -  按钮组件 
   - 功能比 HTML 中的 button 按钮丰富 
   -  通过 open-type 属性可以调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等） 
2. image
   - 图片组件 
   - image 组件默认宽度约 300px、高度约 240px 
3. navigator（后面） 
   - 页面导航组件 
   - 类似于 HTML 中的 a 链接
4. navigator（后面课程会专门讲解） 
   - 页面导航组件
   - 类似于 HTML 中的 a 链接

### 4.6.1 button 按钮的基本使用

![](images\小程序起步\2022-03-02_214921.png)

```css

<!-- 按钮 -->
<view class="tilte">button按钮组件</view>
<view class="btn-box">
  <view class="tilte">通过type指定按钮类型</view>
  <button>默认按钮</button>
  <button type="primary">默认按钮</button>
  <button type="warn">默认按钮</button>
  <view class="tilte">size="min"小尺寸按钮</view>
  <view class="btn-size-box">
    <button size="mini">默认按钮</button>
    <button size="mini" type="primary">默认按钮</button>
    <button size="mini" type="warn">默认按钮</button>
  </view>
  <view class="tilte">plain镂空按钮</view>
  <view class="btn-size-box">
    <button size="mini" plain>默认按钮</button>
    <button size="mini" type="primary" plain>默认按钮</button>
    <button size="mini" type="warn" plain>默认按钮</button>
  </view>
</view>

.btn-box button{
  margin-top: 10px;
}
.btn-size-box{
 /*  text-align: center; */
 display: flex;
 justify-content: center;
}
```

### 4.6.2image 组件的基本使用

- **image 组件的 mode 属性**

  image 组件的 mode 属性用来指定图片的裁剪和缩放模式，常用的 mode 属性值如下：

  | node值      |                                                              |
  | ----------- | ------------------------------------------------------------ |
  | scaleToFill | （默认值）缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素 |
  | aspectFit   | 缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。 |
  | aspectFill  | 向是完整的，另一个方向将会发生截取。                         |
  | widthFix    | 缩放模式，宽度不变，高度自动变化，保持原图宽高比不变         |
  | heightFix   | 缩放模式，高度不变，宽度自动变化，保持原图宽高比不变         |

  ![](images\小程序起步\2022-03-02_221931.png)

```css
<!-- image
    mode 属性:
    scaleToFill:默认值）缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素
    aspectFit:缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。
    aspectFill :缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方
               向是完整的，另一个方向将会发生截取。
    widthFix:缩放模式，宽度不变，高度自动变化，保持原图宽高比不变
    heightFix:缩放模式，高度不变，宽度自动变化，保持原图宽高比不变
 -->
<view class="tilte">image组件</view>
<view class="img-box">
  <view class="tilte">image默认宽高</view>
  <view>
    <image src="" alt="" />
  </view>
  <view class="tilte">image默认</view>
  <view>
    <image src="../images/0.jfif" alt="" />
  </view>
  <view class="tilte">mode:scaleToFill缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满image元素</view>
  <view>
    <image src="../images/0.jfif" alt="" mode="scaleToFill" />
  </view>
  <view class="tilte">mode:aspectFit缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。</view>
  <view>
    <image src="../images/0.jfif" alt="" mode="aspectFit" />
  </view>
  <view class="tilte">mode:aspectFill缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方
    向是完整的，另一个方向将会发生截取。</view>
  <view>
    <image src="../images/0.jfif" alt="" mode="aspectFill" />
  </view>
  <view class="tilte">mode:widthFix缩放模式，宽度不变，高度自动变化，保持原图宽高比不变</view>
  <view>
    <image src="../images/0.jfif" alt="" mode="widthFix" />
  </view>
  <view class="tilte">mode:heightFix缩放模式，高度不变，宽度自动变化，保持原图宽高比不变</view>
  <view>
    <image src="../images/0.jfif" alt="" mode="heightFix" />
  </view>
</view>

.img-box{
  display: flex;
  /* justify-content: center; */
  align-items: center;
  flex-direction: column;
}
.img-box view{
  flex: 1;

}
.img-box image{
  border: 1px solid lightskyblue;
}
```

![](images\小程序起步\2022-03-02_223315.png)

## 4.7API

### **4.7.1小程序 API 概述**

**小程序中的 API 是由宿主环境提供的**，通过这些丰富的小程序 API，开发者可以方便的调用微信提供的能力， 

例如：获取用户信息、本地存储、支付功能等。

### **4.7.2小程序 API 的 3 大分类**

小程序官方把 API 分为了如下 3 大类： 

1. 事件监听 API 

   特点：以 on 开头，用来监听某些事件的触发 

   举例：wx.onWindowResize(function callback) 监听窗口尺寸变化的事件 

2. 同步 API 

   特点1：以 Sync 结尾的 API 都是同步 API 

   特点2：同步 API 的执行结果，可以通过函数返回值直接获取，如果执行出错会抛出异常 

   举例：wx.setStorageSync('key', 'value') 向本地存储中写入内容 

3. 异步 API

   特点：类似于 jQuery 中的 $.ajax(options) 函数，需要通过 success、fail、complete 接收调用的结果 

   举例：wx.request() 发起网络数据请求，通过 success 回调函数接收数据

# **5、协同工作和发布** 

## 5.1**协同工作** 

### 5.1.1了解权限管理需求

​	在中大型的公司里，人员的分工非常仔细：同一个小程序项目，一般会有不同岗位、不同角色的员工同时参与 

设计与开发。 

​	此时出于管理需要，我们**迫切需要对**不同岗位、不同角色的**员工的权限进行边界的划分**，使他们能够高效的进 

行协同工作。

### **5.1.2了解项目成员的组织结构**

![](images\小程序起步\2022-03-03_094604.png)

### 5.1.3小程序的开发流程

![](images\小程序起步\2022-03-03_094706.png)

## 5.2小程序成员管理

小程序成员管理体现在管理员对小程序项目成员及体验成员的管理：

### 5.2.1项目成员：

- 表示参与小程序开发、运营的成员 
- 可登录小程序管理后台 
- 管理员可以添加、删除项目成员，并设置项目成员的角色

### 5.2.2体验成员：

- 表示参与小程序内测体验的成员
- 可使用体验版小程序，但不属于项目成员 
- 管理员及项目成员均可添加、删除体验成员

![](images\小程序起步\2022-03-03_095014.png)

### 	5.2.3不同项目成员对应的权限

|      权限      | 运营者 | 开发者 | 数据分析者 |
| :------------: | :----: | :----: | :--------: |
|   开发者权限   |        |   √    |            |
|   体验者权限   |   √    |   √    |     √      |
|      登录      |   √    |   √    |     √      |
|    数据分析    |        |        |     √      |
|    微信支付    |   √    |        |            |
|      推广      |   √    |        |            |
|    开发管理    |   √    |        |            |
|    开发设置    |        |   √    |            |
|    暂停服务    |   √    |        |            |
| 解除关联公众号 |   √    |        |            |
|   腾讯云管理   |        |   √    |            |
|   小程序插件   |   √    |        |            |
|  游戏运营管理  |   √    |        |            |

## 5.3开发者的权限说明

开发者权限：可使用小程序开发者工具及对小程序的功能进行代码开发 

1.  **体验者权限**：可使用体验版小程序 
2.  **登录权限**：可登录小程序管理后台，无需管理员确认 
3.  **开发设置**：设置小程序服务器域名、消息推送及扫描普通链接二维码打开小程序 
4. 腾讯云管理：云开发相关设置

## 5.4添加项目成员和体验成员

![](J:\学习笔记\study-notes\微信小程序\images\小程序起步\2022-03-03_100118.png)

## 5.5小程序的版本

### 5.5.1软件开发过程中的不同版本

**在软件开发过程中，根据时间节点的不同，会产出不同的软件版本，例如：** 

1. 开发者编写代码的同时，对项目代码进行自测**（开发版本）** 
2. 直到程序达到一个稳定可体验的状态时，开发者把**体验版本**给到产品经理和测试人员进行体验测试
3. 最后修复完程序的Bug 后，发布**正式版**供外部用户使用

### 5.5.2小程序的版本

|   版本阶段   | 说明                                                         |
| :----------: | :----------------------------------------------------------- |
|   开发版本   | 使用开发者工具，可将代码上传到开发版本中。开发版本只保留每人最新的一份上传的代码。         点击提交审核，可将代码提交审核。开发版本可删除，不影响线上版本和审核中版本的代码。 |
|   体验版本   | 可以选择某个开发版本作为体验版，并且选取一份体验版。         |
| 审核中的版本 | 只能有一份代码处于审核中。有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本。 |
|   线上版本   | 线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新。 |

## 5.6发布上线

一个小程序的发布上线，一般要经过**上传代码-> 提交审核-> 发布**这三个步骤。

### 5.6.1上传代码

点击开发者工具顶部工具栏中的**“上传”**按钮

- 填写版本号以及项目备注

![](images\小程序起步\2022-03-03_101201.png)

### 5.6.2在后台查看上传之后的版本

**登录小程序管理后台-> 管理-> 版本管理-> 开发版本**，即可查看刚才提交上传的版本了：

![](images\小程序起步\2022-03-03_101311.png)

## 5.7发布上线

1. ​	为什么需要提交审核：为了保证小程序的质量，以及符合相关的规范，小程序的发布是需要经过腾讯官方审核的。 
2. 提交审核的方式：在开发版本的列表中，点击“提交审核”按钮之后，按照页面提示填写相关的信息，就能把小程序提交到腾讯官方进行审核。

![](images\小程序起步\2022-03-03_101525.png)

## 5.8发布上线

### 5.8.1发布

​	审核通过之后，管理员的微信中会收到小程序通过审核的通知，此时在审核版本的列表中，点击“发布”按钮

之后，即可把“审核通过”的版本发布为“线上版本”，供所有小程序用户访问和使用。

![](images\小程序起步\2022-03-03_101641.png)

### 5.8.2基于小程序码进行推广

相对于普通二维码来说，小程序码的优势如下： 

1. 在样式上更具辨识度和视觉冲击力 

2. 能够更加清晰地树立小程序的品牌形象 

3. 可以帮助开发者更好地推广小程序 

   获取小程序码的5 个步骤： 

   **登录小程序管理后台-> 设置-> 基本设置-> 基本信息-> 小程序码及线下物料下载**

![](images\小程序起步\2022-03-03_102034.png)

## 5.9运营数据

- 在“小程序后台”查看

  登录小程序管理后台**------->**点击侧边栏的“统计”**------->**点击相应的tab 可以看到相关的数据

- 使用“小程序数据助手”查看

​		打开微信 搜索**------->**''小程序数据助手''**------->**查看已发布的小程序相关的数据

# 6.总结：

1.能够知道如何创建小程序项目

- 微信开发者工具的使用、appID 的获取

2.能够清楚小程序项目的基本组成结构

- app.js、app.json、app.wxss、pages 文件夹

3.能够知道小程序页面由几部分组成

- wxml、wxss、json、js

4.能够知道小程序中常见的组件如何使用

- view、text、image

5.能够知道小程序如何进行协同开发和发布

- 成员管理、发布小程序、查看运营数据

# 二、小程序  模板与配置

# 1、WXML 模板语法

## 1.1数据绑定

### 1.1.1数据绑定的基本原则

1. 在data 中定义数据
2. 在WXML 中使用数据

### 1.1.2在data 中定义页面的数据

在页面对应的.js 文件中，把数据定义到data 对象中即可：

```js
  data: {
    info:'hello world!',//字符串类型
     list:['小米','华为', '苹果']//数组
  },
```

### 1.1.3. Mustache 语法的格式

​	把data中的数据绑定到页面中渲染，使用**Mustache 语法**（双大括号）将变量包起来即可。语法格式为：

```js
<view>{{绑定的数据名称}}</view>
```

### 1.1.4 Mustache 语法的应用场景

绑定内容 、绑定属性 、运算（三元运算、算术运算等）

### 1.1.5动态绑定内容

```js
/*********页面结构****************/
<!-- <view>{{绑定的数据名称}}</view>
      不管是内容绑定还是数据绑定都要使用Mustache 语法
 -->
<view class="tilte">数据绑定</view>
<view class="view-text-center">{{info}}</view>

/*********页面数据****************/
  data: {
    info:'hello world!',
  },
```

### 1.1.5 动态绑定属性

```js
/*********页面结构****************/
<view class="tilte">动态绑定数据值</view>
<view class="view-text-center">
  <image src="{{imgSrc}}" mode="widthFix"></image>
</view>

/*********页面数据****************/
 data: {
    imgSrc:'../images/0.jfif',
  },
```

### 1.1.6三元运算和算术运算

```js
/*********页面结构****************/
<view class="tilte"> 三元运算</view>
<view class="view-text-center">{{randNumber1 >=5 ? '数字大于5' : '数字小于5'}}</view>
<view class="tilte"> 算数运算</view>
<view class="view-text-center">{{randNumber2*100}}</view>

/*********页面数据****************/
 data: {
    randNumber1:Math.random()*10,//生成10以内的数
    randNumber2:Math.random().toFixed(2),//生成带两位的小数
  },
```

## 1.2事件绑定

### 1.2.1什么是事件

事件是渲染层到逻辑层的通讯方式。通过事件可以将用户在渲染层产生的行为，反馈到逻辑层进行业务的处理。

![](images\模板与配置\2022-03-03_151153.png)

### 1.2.2小程序中常用的事件

| 类型   | 绑定方式                  | 事件描述                                        |
| ------ | ------------------------- | ----------------------------------------------- |
| tap    | bindtap 或 bind:tap       | 手指触摸后马上离开，类似于 HTML 中的 click 事件 |
| input  | bindinput 或 bind:input   | 文本框的输入事件                                |
| change | bindchange 或 bind:change | 状态改变时触发                                  |

### 1.2.3事件对象的属性列表

**当事件回调触发的时候，会收到一个事件对象 event**，它的详细属性如下表所示：

|      属性      |  类型   | 说明                                         |
| :------------: | :-----: | :------------------------------------------- |
|      type      | String  | 事件类型                                     |
|   timeStamp    | Integer | 页面打开到触发事件所经过的毫秒数             |
|     target     | Object  | 触发事件的组件的一些属性值集合               |
| currentTarget  | Object  | 当前组件的一些属性值集合                     |
|     detail     | Object  | 额外的信息                                   |
|    touches     |  Array  | 触摸事件，当前停留在屏幕中的触摸点信息的数组 |
| changedTouches |  Array  | 触摸事件，当前变化的触摸点信息的数组         |

### 1.2.4 target 和 currentTarget 的区别 

**target 是触发该事件的源头组件，而 currentTarget 则是当前事件所绑定的组件**。举例如下：

![](images\模板与配置\2022-03-03_152317.png)

​	点击内部的按钮时，点击事件以**冒泡**的方式向外扩散，也会触发外层view 的tap 事件处理函数。 

此时，对于外层的view 来说： 

- e.target指向的是触发事件的源头组件，因此，e.target是内部的按钮组件 
- e.currentTarget指向的是当前正在触发事件的那个组件，因此，e.currentTarget是当前的view 组件

###  1.2.5bindtap 的语法格式

在小程序中，不存在HTML 中的onclick 鼠标点击事件，而是通过tap 事件来响应用户的触摸行为。

1. 通过bindtap，可以为组件绑定tap 触摸事件，语法如下：

```js
<!-- 通过 bindtap，可以为组件绑定 tap 触摸事件 -->
<view class="tilte"> 组件绑定事件</view>
<button type="primary" bindtap="btnTapHeadle">点击事件按钮</button>
```

1. 在页面的.js 文件中定义对应的事件处理函数，事件参数通过形参event（一般简写成e）来接收：

```js
 // 按钮处理函数
  btnTapHeadle(e){
    console.log(e);
  }
```

### 1.2.6 在事件处理函数中为data 中的数据赋值

​	通过调用this.setData(dataObject) 方法，可以给页面data 中的数据重新赋值，示例如下：

```js
<!-- 调用 this.setData(dataObject)
      改变data中的数据
 -->
<view class="tilte"> 调用 this.setData()方法</view>
<view class="view-text-center">count:{{count}}</view>
<button type="warn" bindtap="btnCountHeadle">count+1</button>

 data: {
    count:0
  },
// 点击按钮count+1事件处理函数
  btnCountHeadle(){
    this.setData({
      count:this.data.count+1
    })
  }
```

### 1.2.7 事件传参

- 小程序中的事件传参比较特殊，不能在绑定事件的同时为事件处理函数传递参数。例如，下面的代码将不能正

常工作：

```js
<button type="warn" bindtap="btnDataHeadle(num)">count+num</button>
```

因为小程序会把bindtap 的属性值，统一当作事件名称来处理，相当于要调用一个名称为btnHandler(123) 

的事件处理函数。

- 可以为组件提供data-*自定义属性传参，其中星号 代表的是参数的名字，
- 在事件处理函数中，通过event.target.dataset.参数名即可获取到具体参数的值，示例代码如下：

```js
<!--  事件传参
      1.小程序中的事件传参比较特殊，不能在绑定事件的同时为事件处理函数传递参数
      2.小程序会把 bindtap 的属性值，统一当作事件名称来处理
      3.可以为组件提供 data-* 自定义属性传参，其中 * 代表的是参数的名字
      4.在事件处理函数中，通过 event.target.dataset.参数名 即可获取到具体参数的值
 -->
<view class="tilte"> 事件传参</view>
<view class="view-text-center"> num=2 count+num:{{count}} </view>
<button type="warn" bindtap="btnDataHeadle" data-num="{{2}}">count+num</button>


 data: {
    count:0
  },
// 事件传参处理函数
  btnDataHeadle(event){
    this.setData({
      count:this.data.count+event.target.dataset.num
    })
  }
```

**最终： info会被解析为参数的名字数值2会被解析为参数的值**

### 1.2.8 bindinput 的语法格式

在小程序中，通过input 事件来响应文本框的输入事件，语法格式如下：

```js
<!-- bindinput 的语法格式
     1.通过 bindinput，可以为文本框绑定输入事件
     2.通过event.detail.value来获取文本最新值
 -->
<view class="tilte"> bindinput</view>
<view class="view-text-center">inputValue:</view>
<view class="view-text-center">{{inputValue}}</view>
<view class="inputBox">
  <input type="text" bindinput="inputValueHeadeal" />
</view>

 data: {
    inputValue:'',
  },
 inputValueHeadeal(event){
    // console.log(event.detail.value);
    this.setData({
      inputValue:event.detail.value
    })
  }
```

### 1.2.9实现文本框和data 之间的数据同步

实现步骤： 

- 定义数据 
- 渲染结构 
- 美化样式 
- 绑定input 事件处理函数

```js
//1.定义数据 
data: {
    msg:'你好，'
  },
 //2.渲染结构 
<!--通过value属性来实现文本框和 data 之间的数据同步  -->
<view class="tilte"> 文本框和data之间的数据同步</view>
<view class="view-text-center">msg:</view>
<view class="view-text-center">{{msg}}</view>
<view class="inputBox">
  <input type="text" value="{{msg}}" bindinput="inputMsgHeadeal" />
</view>
//3.美化样式 
.inputBox{
  /* border: 1px solid rgb(14, 15, 15); */
  width: 300px;
  margin: 0 auto;
}
input{
  border: 1px solid rgb(231, 143, 28);
  margin: 5px;
  padding: 5px;
  border-radius: 3px;
}
//4.绑定input 事件处理函数
  inputMsgHeadeal(event){
    // console.log(event.detail.value);
    this.setData({
      msg:event.detail.value
    })
  },
```

## 1.3条件渲染

### 1.3.1wx:if

在小程序中，使用wx:if="{{condition}}"来判断是否需要渲染也可以用wx:elif 和wx:else 来添加else 判断：

```js
<!--条件渲染：wx:if -->
<view class="tilte"> 文本框和data之间的数据同步</view>
<view class="view-text-center">
  <veiw wx:if="{{type===1}}">男</veiw>
  <veiw wx:elif="{{type===2}}">女</veiw>
  <veiw wx:else>不确定</veiw>
</view>

  data: {
    type:1,
  }
```

### 1.3.2结合使用wx:if

​	 如果要一次性控制多个组件的展示与隐藏，可以使用一个标签将多个组件包装起来，并在标签上使用wx:if 控制属性，示例如下：

```js
<!-- 如果要一次性控制多个组件的展示与隐藏，可以使用一个 <block></block> 标签将多个组件包装起来，并在
      <block> 标签上使用 wx:if 控制属性 
-->
<view class="tilte"> block 标签</view>
<block wx:if="{{true}}">
  <view class="view-text-center">1</view>
  <view class="view-text-center">2</view>
  <view class="view-text-center">3</view>
</block>
```

**注意：并不是一个组件，它只是一个包裹性质的容器，不会在页面中做任何渲染。

### 1.3.3hidden

在小程序中，直接使用hidden="{{ condition }}"也能控制元素的显示与隐藏：

```js
<!-- hidden="{{ condition }}"也能控制元素的显示与隐藏： -->
<view class="tilte"> hidden</view>
<view class="view-text-center" hidden="{{flag}}">条件为true隐藏,条件为false显示</view>
```

### 1.3.4wx:if 与hidden 的对比

1. 运行方式不同
   - wx:if 以动态创建和移除元素的方式，控制元素的展示与隐藏 
   - hidden 以切换样式的方式（display: none/block;），控制元素的显示与隐藏
2. 使用建议
   - 频繁切换时，建议使用hidden 
   - 控制条件复杂时，建议使用wx:if搭配wx:elif、wx:else 进行展示与隐藏的切换

## 1.4列表渲染

### 1.4.1 wx:for

通过wx:for 可以根据指定的数组，循环渲染重复的组件结构，语法示例如下：

```js
<!-- 列表渲染：wx:for
    通过wx:for 可以根据指定的数组，循环渲染重复的组件结构
 -->
<view class="tilte"> wx:for</view>
<view wx:for="{{arr1}}" wx:key="index" class="view-text-center">
  索引：{{index}} ,item 项：{{item}}
</view>

  data: {
    arr1:['苹果','华为','小米']
  },
```

**默认情况下，当前循环项的索引用index表示；当前循环项用item表示。**

### 1.4.2手动指定索引和当前项的变量名（了解）

- 使用wx:for-index 可以指定当前循环项的索引的变量名
- 使用wx:for-item 可以指定当前项的变量名

```js
<!-- 动指定索引和当前项的变量名
    1.使用wx:for-index 可以指定当前循环项的索引的变量名
    2.使用wx:for-item 可以指定当前项的变量名
-->
<view class="tilte">wx:for-item和wx:for-index</view>
<view wx:for="{{arr1}}" wx:for-index="itx" wx:for-item='itemName' wx:key="itx" class="view-text-center">
  索引：{{itx}} ,item 项：{{itemName}}
</view>

 data: {
    arr1:['苹果','华为','小米']
  },
```

### 1.4.3wx:key 的使用

​	类似于Vue 列表渲染中的:key，小程序在实现列表渲染时，也建议为渲染出来的列表项指定唯一的key 值，

从而**提高渲染的效率**，示例代码如下：

```js
<!--wx:key 的使用
    可以使渲染出来的列表项指定唯一的key 值，从而提高渲染的效率，
 -->
<view class="tilte">wx:key</view>
<view wx:for="{{userList}}" class="view-text-center" wx:key="id">
  index：{{index}} ,userName：{{item}}
</view>
```

# 2.**WXSS 模板样式**

## 2.1什么是 WXSS

WXSS (WeiXin Style Sheets)是一套样式语言，用于美化 WXML 的组件样式，类似于网页开发中的 CSS。

## 2.2WXSS 和 CSS 的关系

WXSS 具有 CSS 大部分特性，同时，WXSS 还对 CSS 进行了扩充以及修改，以适应微信小程序的开发。 

与 CSS 相比，WXSS 扩展的特性有： 

- rpx 尺寸单位 
- @import 样式导入

![](images\模板与配置\2022-03-03_190121.png)

## 2.3rpx

### 2.3.1什么是rpx 尺寸单位

​	rpx（responsive pixel）是微信小程序独有的，用来解决屏适配的尺寸单位。

### 2.3.2rpx 的实现原理

​	rpx 的实现原理非常简单：鉴于不同设备屏幕的大小不同，为了实现屏幕的自动适配，rpx 把所有设备的屏幕，

在宽度上等分为750 份（即：当前屏幕的总宽度为750rpx）。 

- 在较小的设备上，1rpx 所代表的宽度较小 
- 在较大的设备上，1rpx 所代表的宽度较大 

小程序在不同设备上运行的时候，会自动把rpx 的样式单位换算成对应的像素单位来渲染，从而实现屏幕适配。

### 2.3.3rpx 与px 之间的单位换算（了解）

在iPhone6 上，屏幕宽度为375px，共有750 个物理像素，等分为750rpx。则：

750rpx= 375px= 750 物理像素

**1rpx= 0.5px= 1物理像素**

| 设备         | rpx换算px (屏幕宽度/750) | px换算rpx (750/屏幕宽度) |
| ------------ | ------------------------ | ------------------------ |
| iPhone5      | 1rpx = 0.42px            | 1px = 2.34rpx            |
| iPhone6      | 1rpx = 0.5px             | 1px = 3rpx               |
| iPhone6 Plus | 1rpx = 0.552px           | 1px = 1.81rpx            |

官方建议：开发微信小程序时，设计师可以用 iPhone6 作为视觉稿的标准。 

开发举例：在 iPhone6 上如果要绘制宽100px，高20px的盒子，换算成rpx单位，宽高分别为 200rpx 和 40rpx。

## 2.4**样式导入**

### 2.4.1 什么是样式导入**

使用 WXSS 提供的 @import 语法，可以导入外联的样式表。

### 2.4.2**@import 的语法格式** 

@import 后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束。示例如下：

![](images\模板与配置\2022-03-03_191116.png)

## 2.5全局样式和局部样式

### 2.5.1全局样式 

定义在app.wxss 中的样式为全局样式，作用于每一个页面。

### 2.5.2局部样式 

在页面的.wxss文件中定义的样式为局部样式，只作用于当前页面。 

注意： 

1. 当局部样式和全局样式冲突时，根据就近原则，局部样式会覆盖全局样式
2. 当局部样式的权重大于或等于全局样式的权重时，才会覆盖全局的样式

# 3.全局配置

## 3.1全局配置文件及常用的配置项

小程序根目录下的app.json 文件是小程序的全局配置文件。常用的配置项如下：

1. pages：记录当前小程序所有页面的存放路径
2. window：全局设置小程序窗口的外观
3. tabBar：设置小程序底部的tabBar效果
4. style：是否启用新版的组件样式

### 3.1.1window

小程序窗口的组成部分：

- navigationBar：导航栏区域
- background：背景区域，默认不可见，下拉才显示
- 页面主题区域：显示wxml中的布局

![](images\模板与配置\2022-03-03_191641.png)

### 3.1.2了解window 节点常用的配置项

|            属性名            |   类型   | 默认值  | 说明                                           |
| :--------------------------: | :------: | :-----: | :--------------------------------------------- |
|    navigationBarTitleText    |  String  | 字符串  | 导航栏标题文字内容                             |
| navigationBarBackgroundColor | HexColor | #000000 | 导航栏背景颜色，如 #000000                     |
|    navigationBarTextStyle    |  String  |  white  | 导航栏标题颜色，仅支持 black / white           |
|       backgroundColor        | HexColor | #ffffff | 窗口的背景色                                   |
|     backgroundTextStyle      |  String  |  dark   | 下拉 loading 的样式，仅支持 dark / light       |
|    enablePullDownRefresh     | Boolean  |  FALSE  | 是否全局开启下拉刷新                           |
|    onReachBottomDistance     |  Number  |   50    | 页面上拉触底事件触发时距页面底部距离，单位为px |

### 3.1.3设置导航栏的标题

设置步骤：**app.json -> window -> navigationBarTitleText** 

需求：把导航栏上的标题，从默认的 “WeChat”修改为“wenyuStudy”，效果如图所示：

![](images\模板与配置\2022-03-03_192958.png)

### 3.1.4设置导航栏的背景色

设置步骤：**app.json -> window -> navigationBarBackgroundColor** 

需求：把导航栏标题的背景色，从默认的 #fff 修改为 #ccc：

![](images\模板与配置\2022-03-03_194836.png)

### 3.1.5设置导航栏的标题颜色

设置步骤：**app.json -> window -> navigationBarTextStyle** 

需求：把导航栏上的标题颜色，从默认的 black 修改为 white ，效果如图所示： 

![](images\模板与配置\2022-03-03_194922.png)

**注意： navigationBarTextStyle 的可选值只有 black 和 white**

### 3.1.6全局开启下拉刷新功能

概念：下拉刷新是移动端的专有名词，指的是通过手指在屏幕上的下拉滑动操作，从而重新加载页面数据的行为。 

设置步骤**：app.json -> window -> 把 enablePullDownRefresh 的值设置为 true** 

注意：在 app.json 中启用下拉刷新功能，会作用于每个小程序页面！

### 3.1.7 设置下拉刷新时窗口的背景色

当全局开启下拉刷新功能之后，默认的窗口背景为白色。如果自定义下拉刷新窗口背景色，设置步骤为:  

**app.json -> window -> 为 backgroundColor** 指定16进制的颜色值 #efefef。效果如下：

![](images\模板与配置\2022-03-03_195426.png)

### 3.1.8设置下拉刷新时 loading 的样式

当全局开启下拉刷新功能之后，默认窗口的 loading 样式为白色，如果要更改 loading 样式的效果，设置步 

骤为 **app.json -> window -> 为 backgroundTextStyle** 指定 dark 值。效果如下：

![](images\模板与配置\2022-03-03_195751.png)

**注意： backgroundTextStyle 的可选值只有 light 和 dark**

### 3.1.9**设置上拉触底的距离** 

概念：上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为。 

设置步骤： **app.json -> window -> 为 onReachBottomDistance 设置新的数值** 

**注意：默认距离为50px，如果没有特殊需求，建议使用默认值即可。**

## 3.2**tabBar** 

### 3.2.1什么是 tabBar

tabBar 是移动端应用常见的页面效果，用于实现多页面 

的快速切换。小程序中通常将其分为： 

- 底部 tabBar 

-  顶部 tabBar

![](images\模板与配置\2022-03-03_200340.png)

**注意：** 

- tabBar中只能配置最少2 个、最多5 个tab 页签
- 当渲染顶部tabBar 时，不显示icon，只显示文本

### 3.2.2 tabBar 的6 个组成部分

![](images\模板与配置\2022-03-03_200446.png)

1. backgroundColor：tabBar 的背景色 
2. selectedIconPath：选中时的图片路径 
3. borderStyle：tabBar 上边框的颜色 
4. iconPath：未选中时的图片路径 
5. selectedColor：tab 上的文字选中时的颜色
6. color：tab 上文字的默认（未选中）颜色

### 3.2.3tabBar 节点的配置项

| **属性**        | **类型** | **必填** | **默认值** | **描述**                                    |
| --------------- | -------- | -------- | ---------- | ------------------------------------------- |
| position        | String   | 否       | bottom     | tabBar  的位置，仅支持 bottom/top           |
| borderStyle     | String   | 否       | black      | tabBar  上边框的颜色，仅支持 black/white    |
| color           | HexColor | 否       |            | tab  上文字的默认（未选中）颜色             |
| selectedColor   | HexColor | 否       |            | tab  上的文字选中时的颜色                   |
| backgroundColor | HexColor | 否       |            | tabBar  的背景色                            |
| list            | Array    | 是       |            | tab  页签的列表，  最少 2 个、最多 5 个 tab |

### 3.2.4 每个 tab 项的配置选项

| **属性**        | **类型** | **必填** | **默认值** | **描述**                                    |
| --------------- | -------- | -------- | ---------- | ------------------------------------------- |
| position        | String   | 否       | bottom     | tabBar  的位置，仅支持 bottom/top           |
| borderStyle     | String   | 否       | black      | tabBar  上边框的颜色，仅支持 black/white    |
| color           | HexColor | 否       |            | tab  上文字的默认（未选中）颜色             |
| selectedColor   | HexColor | 否       |            | tab  上的文字选中时的颜色                   |
| backgroundColor | HexColor | 否       |            | tabBar  的背景色                            |
| list            | Array    | 是       |            | tab  页签的列表，  最少 2 个、最多 5 个 tab |

### 2.2.5案例：配置 tabBar

**1. 需求描述** :根据资料中提供的小图标、 在小程序中配置如图所示的 tabBar 效果：

![](images\模板与配置\2022-03-03_201149.png)

**2. 实现步骤** 

① 拷贝图标资源 

② 新建 3 个对应的 tab 页面 

③ 配置 tabBar 选项

**步骤1 -** **拷贝图标资源** 

① 把资料目录中的 images 文件夹，拷贝到小程序项目根目录中 

② 将需要用到的小图标分为 3 组，每组两个，其中： 

-  图片名称中包含 -active 的是选中之后的图标 
-  图片名称中不包含 -active 的是默认图标 

截图如下：

![](images\模板与配置\2022-03-03_201242.png)

**3. 步骤2 -** **新建 3 个对应的 tab 页面** 

![](images\模板与配置\2022-03-03_201325.png)

**其中，home 是首页，message 是消息页面，contact 是联系我们页面。**

**3. 步骤3 -** **配置 tabBar 选项**

① 打开 app.json 配置文件，和 pages、window 平级，新增 tabBar 节点 

② tabBar 节点中，新增 list 数组，这个数组中存放的，是每个 tab 项的配置对象 

③ 在 list 数组中，新增每一个 tab 项的配置对象。对象中包含的属性如下： 

- pagePath 指定当前 tab 对应的页面路径【必填】 
-  text 指定当前 tab 上按钮的文字【必填】 
-  iconPath 指定当前 tab 未选中时候的图片路径【可选】 
- selectedIconPath 指定当前 tab 被选中后高亮的图片路径【可选】

**完整的配置代码**

![](images\模板与配置\2022-03-03_201532.png)

# 4.**页面配置**

## 4.1页面配置文件的作用

小程序中，每个页面都有自己的 .json 配置文件，用来对当前页面的窗口外观、页面效果等进行配置

## 4.2页面配置和全局配置的关系

小程序中，app.json 中的 window 节点，可以全局配置小程序中每个页面的窗口表现。 

如果某些小程序页面想要拥有特殊的窗口表现，此时，“页面级别的 .json 配置文件”就可以实现这种需求。  

**注意：当页面配置与全局配置冲突时，根据就近原则，最终的效果以页面配置为准。**

## 4.3 页面配置中常用的配置项

| **属性**                     | **类型** | **默认值** | **描述**                                           |
| ---------------------------- | -------- | ---------- | -------------------------------------------------- |
| navigationBarBackgroundColor | HexColor | #000000    | 当前页面导航栏背景颜色，如 #000000                 |
| navigationBarTextStyle       | String   | white      | 当前页面导航栏标题颜色，仅支持 black /  white      |
| navigationBarTitleText       | String   |            | 当前页面导航栏标题文字内容                         |
| backgroundColor              | HexColor | #ffffff    | 当前页面窗口的背景色                               |
| backgroundTextStyle          | String   | dark       | 当前页面下拉 loading  的样式，仅支持 dark /  light |
| enablePullDownRefresh        | Boolean  | false      | 是否为当前页面开启下拉刷新的效果                   |
| onReachBottomDistance        | Number   | 50         | 页面上拉触底事件触发时距页面底部距离，单位为 px    |

# 5.**网络数据请求**

## 5.1 **小程序中网络数据请求的限制**

出于安全性方面的考虑，小程序官方对数据接口的请求做出了如下 两个限制：

1. 只能请求 HTTPS 类型的接口
2. 必须将接口的域名添加到信任列表中

<img src="images\模板与配置\图片1.png" style="zoom:60%;" />

## 5.2配置 **request** **合法域名**

需求描述：假设在自己的微信小程序中，希望请求 https://[www.escook.cn/](http://www.escook.cn/) 域名下的接口 配置步骤：

**登录微信小程序管理后台 -> 开发 -> 开发设置 -> 服务器域名 -> 修改 request 合法域名**

注意事项：

1.  域名只支持 https 协议
2. 域名不能使用 IP 地址或 localhost
3. 域名必须经过 ICP 备案
4. 服务器域名一个月内最多可申请 5 次修改

## 5.3**网络数据请求**

#### 5.3.1发起 **GET** 请求

调用微信小程序提供的 wx.request() 方法，可以发起 GET 数据请求，示例代码如下：

```js
 wx.request({
      url: 'https://www.escook.cn/api/get',
      method:'GET',
      data:{
        name:'zs',
        age:23,
      },
      success:(res)=>{
         console.log(res);
      }
    })
  },
```

#### 5.3.2发起 **POST** 请求

调用微信小程序提供的 wx.request() 方法，可以发起 POST 数据请求，示例代码如下：

```js
    wx.request({
      url: 'https://www.escook.cn/api/post',
      method:'POST',
      data:{
        name:"张三",
        age:25
      },
      success:(res)=>{
        console.log(res);
      }
    })
```

#### 5.3.3**在页面刚加载时请求数据**

​	在很多情况下，我们需要在页面刚加载的时候，自动请求一些初始化的数据。此时需要在页面的 onLoad 事件

中调用获取数据的函数，示例代码如下：

```js
  onLoad() {
    this.getHeadle(),
    this.postHeadle()
  }
})
```

#### 5.3.4**跳过** **request** **合法域名校验**

​	如果后端程序员仅仅提供了 http 协议的接口、暂时没有提供 https协议的接口。

​	此时为了不耽误开发的进度，我们可以在微信开发者工具中，临时 开启「开发环境不校验请求域名、TLS 版本及 HTTPS 证书选项， 跳过 request 合法域名的校验。

<img src="images\模板与配置\图片2.png" style="zoom:48%;" />

**注意：跳过 request 合法域名校验的选项，仅限在开发与调试阶段使用！**

#### 5.3.5**关于跨域和 **Ajax **的说明**

- 跨域问题只存在于基于浏览器的 Web 开发中。由于小程序的宿主环境不是浏览器，而是微信客户端，所以小 程序中不存在跨域的问题。

- Ajax 技术的核心是依赖于浏览器中的 XMLHttpRequest 这个对象，由于小程序的宿主环境是微信客户端，**所 以小程序中不能叫做“发起 Ajax 请求”**，而是叫做**“发起网络数据请求”**。

# 6.总结

1. 能够使用 WXML 模板语法渲染页面结构
   - wx:if、wx:elif、wx:else、hidden、wx:for、wx:key
2. 能够使用 WXSS 样式美化页面结构
   - rpx 尺寸单位、@import 样式导入、全局样式和局部样式
3. 能够使用 app.json 对小程序进行全局性配置
   - pages、window、tabBar、style
4. 能够使用 page.json 对小程序页面进行个性化配置
   - 对单个页面进行个性化配置、就近原则
5. 能够知道如何发起网络数据请求
   - wx.request() 方法、onLoad() 事件

# 三、视图与逻辑

# 1.页面导航

## 1.1**什么是页面导航**

1. 页面导航指的是页面之间的相互跳转。例如，浏览器中实现页面导航的方式有如下两种：
   - a 链接
   -  location.href

## 1.2小程序中实现页面导航的两种方式

1. 声明式导航

   在页面上声明一个 navigator 导航组件，通过点击 navigator组件实现页面跳转

2. 编程式导航

   调用小程序的导航 API，实现页面的跳转

### 1.2.1**声明式导航**

1. **导航到** **tabBar** **页面**

   - tabBar 页面指的是被配置为 tabBar 的页面。

   - 在使用 <navigator> 组件跳转到指定的 tabBar 页面时，需要指定 url 属性和 open-type 属性，其中：
     - url 表示要跳转的页面的地址，必须以 / 开头
     - open-type 表示跳转的方式，必须为 switchTab

   示例代码如下：

   ```html
   <!--  跳转到tabBar页面
         1.url 表示要跳转的页面的地址，必须以 / 开头
         2.open-type 表示跳转的方式，必须为 switchTab
   -->
   <navigator url="/pages/index/index" open-type="switchTab" class="view-text-center">点击导航到模板页面</navigator>
   ```

2. **导航到非** **tabBar** **页面**

   - 非 tabBar 页面指的是没有被配置为 tabBar 的页面。
   - 在使用 navigator组件跳转到普通的非 tabBar 页面时，则需要指定 url 属性和 open-type 属性，其中：
     - url 表示要跳转的页面的地址，必须以 / 开头
     - open-type 表示跳转的方式，必须为 navigate

   示例代码如下：

   ```html
   <!-- 跳转到非tabBar页面
     1.url 表示要跳转的页面的地址，必须以 / 开头
     2. open-type 表示跳转的方式，必须为 navigate
    -->
   <navigator url="/pages/info/info" open-type="navigate" class="view-text-center">点击导航到info页面</navigator>
   ```

   **注意：为了简便，在导航到非 tabBar 页面时，open-type="navigate" 属性可以省略。**

3. **后退导航**

   - 如果要后退到上一页面或多级页面，则需要指定 open-type 属性和 delta 属性，其中：
     - open-type 的值必须是 navigateBack，表示要进行后退导航
     - delta 的值必须是数字，表示要后退的层级

   示例代码如下：

```html
<navigator open-type="navigateBack">返回</navigator>
```

**注意：为了简便，如果只是后退到上一页面，则可以省略 delta 属性，因为其默认值就是 1。**

### 1.2.2**编程式导航**

1. **导航到** **tabBar** **页面**

   调用 wx.switchTab(Object object) 方法，可以跳转到 tabBar 页面。其中 Object 参数对象的属性列表如下：

   | **属性** | **类型** | **是否必选** | **说明**                                         |
   | -------- | -------- | ------------ | ------------------------------------------------ |
   | url      | string   | 是           | 需要跳转的 tabBar  页面的路径，路径后不能带参数  |
   | success  | function | 否           | 接口调用成功的回调函数                           |
   | fail     | function | 否           | 接口调用失败的回调函数                           |
   | complete | function | 否           | 接口调用结束的回调函数（调用成功、失败都会执行） |

   示例代码如下：

   ```js
   <button type="primary" bindtap="goToIndex">跳转到模板页面</button>
   
     goToIndex(){
       wx.switchTab({
         url: '/pages/index/index',
       })
     },
   ```

2. **导航到非** **tabBar** **页面**

   调用 wx.navigateTo(Object object) 方法，可以跳转到非 tabBar 的页面。其中 Object 参数对象的属性列表如下：

   | **属性** | **类型** | **是否必选** | **说明**                                            |
   | -------- | -------- | ------------ | --------------------------------------------------- |
   | url      | string   | 是           | 需要跳转到的非 tabBar  页面的路径，路径后可以带参数 |
   | success  | function | 否           | 接口调用成功的回调函数                              |
   | fail     | function | 否           | 接口调用失败的回调函数                              |
   | complete | function | 否           | 接口调用结束的回调函数（调用成功、失败都会执行）    |

   示例代码如下：

   ```js
   <button type="warn" bindtap="goToInfo">跳转到info页面</button>
   
   
    goToInfo(){
       wx.navigateTo({
         url: '/pages/info/info',
       })
     },
   ```

3. **后退导航**

   调用 wx.navigateBack(Object object) 方法，可以返回上一页面或多级页面。其中 Object 参数对象可选的 属性列表如下：

   | **属性** | **类型** | **默认值** | **是否必选** | **说明**                                               |
   | -------- | -------- | ---------- | ------------ | ------------------------------------------------------ |
   | delta    | number   | 1          | 否           | 返回的页面数，如果 delta  大于现有页面数，则返回到首页 |
   | success  | function |            | 否           | 接口调用成功的回调函数                                 |
   | fail     | function |            | 否           | 接口调用失败的回调函数                                 |
   | complete | function |            | 否           | 接口调用结束的回调函数（调用成功、失败都会执行）       |

   ```js
   <button bindtap="backHeadle">返回</button>
   
   backHeadle(){
       wx.navigateBack({
         delta: 1,
       })
     },
   ```

## 1.3**导航传参**

### 1.3.1**声明式导航传参**

​	navigator 组件的 url 属性用来指定将要跳转到的页面的路径。同时，路径的后面还可以携带参数：

- 参数与路径之间使用 ? 分隔

- 参数键与参数值用 = 相连

- 不同参数用 & 分隔

  代码示例如下：

  ```html
  <navigator url="/pages/info/info?name='zs'&sex='女'" open-type="navigate" class="view-text-center">传参到info页面</navigator>
  ```

  

### 1.3.2**编程式导航传参**

调用 wx.navigateTo(Object object) 方法跳转页面时，也可以携带参数，代码示例如下：

```js
goToInfo2(){
    wx.navigateTo({
      url: '/pages/info/info?name="张三"&sex="男"',
    })
  },
```

# 2.页面事件

## 2.1下拉刷新事件

### 2.1.1什么是下拉刷新

​	下拉刷新是移动端的专有名词，指的是通过手指在屏幕上的下拉滑动操作，从而重新加载页面数据的行为。

 启用下拉刷新

### 2.1.2启用下拉刷新有两种方式

1.  全局开启下拉刷新
   - **在 app.json 的 window 节点中**，将 **enablePullDownRefresh 设置为 true**
2. 局部开启下拉刷新
   - **在页面的 .json 配置文件中**，将 enablePullDownRefresh 设置为 true
   - 在实际开发中，推荐使用第 2 种方式，为需要的页面单独开启下拉刷新的效果。

### 2.1.3配置下拉刷新窗口的样式

​	在全局或页面的 .json 配置文件中，通过 backgroundColor 和 backgroundTextStyle 来配置下拉刷新窗口  的样式，其中：

- **backgroundColor** 用来配置下拉刷新窗口的背景颜色，仅支持16 进制的颜色值
- **backgroundTextStyle** 用来配置下拉刷新 loading 的样式，仅支持 dark 和 light

#### 2.1.4下拉刷新事件

##### **onPullDownRefresh()** 

​	在页面的 .js 文件中，通过 **onPullDownRefresh()** 函数即可监听当前页面的下拉刷新事件。 

​	1.例如，在页面的 wxml 中有如下的 UI 结构，点击按钮可以让 count 值自增 ：

```js
<view class="view-text-center">count:{{count}}</view>
<button type="primary" bindtap="countAdd">count自增</button>

  countAdd(){
    this.setData({
      count:this.data.count+1
    })
  },
```

​	2.在触发页面的下拉刷新事件的时候，如果要把 count 的值重置为 0，示例代码如下：

```js
/**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {
      this.setData({
        count:this.data.count=0
      })
      wx.stopPullDownRefresh()
  }
```

##### 停止下拉刷新的效果

​	当处理完下拉刷新后，下拉刷新的 loading 效果会一直显示，不会主动消失，所以需要手动隐藏下拉刷新的
loading 效果。此时，调用 **wx.stopPullDownRefresh()** 可以停止当前页面的下拉刷新。

示例代码如下：

```js
/**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {
      this.setData({
        count:this.data.count=0
      })
       // 关闭下拉刷新
      wx.stopPullDownRefresh()
  }
```

## 2.2上拉触底事件

### 2.2.1什么是上拉触底

​	上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为。

### 2.2.2 监听页面的上拉触底事件

​	在页面的 .js 文件中，通过 **onReachBottom() 函数**即可监听当前页面的上拉触底事件。示例代码如下：

```js
 /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {
    console.log("触发上拉触底事件");
  },
```

### 2.2.3配置上拉触底距离

​	上拉触底距离指的是触发上拉触底事件时，滚动条距离页面底部的距离。可以在全局或页面的 .json 配置文件中，通过 **onReachBottomDistance** 属性来配置上拉触底的距离。  **小程序默认的触底距离是 50px**，在实际开发中，可以根据自己的需求修改这个默认值。

## 2.3上拉触底案例

### 2.3.1案例效果展示

<img src="images\页面事件\图片1.png" style="zoom:50%;" />

### 2.3.2案例的实现步骤

1. 定义获取随机颜色的方法
2. 在页面加载时获取初始数据
3.  渲染 UI 结构并美化页面效果
4. 在上拉触底时调用获取随机颜色的方法
5. 添加 loading 提示效果
6.  对上拉触底进行节流处理

- 步骤1 - 定义获取随机颜色的方法

  ```js
  getColorList(){
      wx.request({
        url: 'https://www.escook.cn/api/color',
        method:'GET',
        success:({data:res})=>{
          // console.log(res);
          this.setData({
            colorList:[...this.data.colorList,...res.data]
          })
        }
      })
    },
  ```

- 步骤2 - 在页面加载时获取初始数据

  ```
    /**
     * 生命周期函数--监听页面加载
     */
    onLoad: function (options) {
      this.getColorList()
    },
  ```

- 步骤3 - 渲染 UI 结构并美化页面效果

  ```css
  <view wx:for="{{colorList}}" wx:key="index" style="background-color:rgba({{item}});" class="num-item">{{item}}
  </view>
  
  .num-item{
    height: 150rpx;
    line-height: 150rpx ;
    text-align: center;
    margin: 15rpx;
    border-radius: 8rpx;
    text-shadow: 0rpx 0rpx 5rpx #ffffff;
    box-shadow: 1rpx 1rpx 6rpx #aaa;
  }
  ```

- 步骤4 - 上拉触底时获取随机颜色

  ```js
    onLoad: function (options) {
      this.getColorList()
    },
  ```

- 步骤5 - 添加 loading 提示效果

  ```js
  getColorList(){
      wx.showLoading({
        title: '数据加载中...',//展示Loading效果
      })
      wx.request({
        url: 'https://www.escook.cn/api/color',
        method:'GET',
        success:({data:res})=>{
          // console.log(res);
        
          this.setData({
            colorList:[...this.data.colorList,...res.data]
          })
        },
        complete:()=>{
          wx.hideLoading()//关闭Loading效果
        }
      })
    },
  ```

- 步骤6 - 对上拉触底进行节流处理

  1. 在 data 中定义 isloading 节流阀
     - false 表示当前没有进行任何数据请求
     - true 表示当前正在进行数据请求
  2.  在 getColors() 方法中修改 isloading 节流阀的值
     - 在刚调用 getColors 时将节流阀设置 true
     - 在网络请求的 complete 回调函数中，将节流阀重置为 false
  3. 在 onReachBottom 中判断节流阀的值，从而对数据请求进行节流控制
     - 如果节流阀的值为 true，则阻止当前请求
     - 如果节流阀的值为 false，则发起数据请求

  ```js
    Page({
  
    /**
     * 页面的初始数据
     */
    data: {
      colorList:[],
      flag:false
    },
    getColorList(){
      this.setFlag(true)
      wx.showLoading({
        title: '数据加载中...',//展示Loading效果
      })
      wx.request({
        url: 'https://www.escook.cn/api/color',
        method:'GET',
        success:({data:res})=>{
          // console.log(res);
        
          this.setData({
            colorList:[...this.data.colorList,...res.data]
          })
        },
        complete:()=>{
          wx.hideLoading()//关闭Loading效果
          this.setFlag(false)
        }
      })
    },
    setFlag(num){
      this.setData({
        flag:this.data.flag=num
      })
    },
    /**
     * 生命周期函数--监听页面加载
     */
    onLoad: function (options) {
      this.getColorList()
    },
    /**
     * 页面上拉触底事件的处理函数
     */
    onReachBottom: function () {
      if(this.data.flag){
        return
      }
      else{
        this.getColorList()
      }
       
    },
  ```

  

# 3.扩展

## 3.1自定义编译模式



![](images\页面事件\2022-03-05_104925.png)

# 4.生命周期

1.生命周期（Life Cycle）是指一个对象从创建 -> 运行 -> 销毁的整个阶段，强调的是一个时间段。例如：

- 张三出生，表示这个人生命周期的开始
- 张三离世，表示这个人生命周期的结束
- 中间张三的一生，就是张三的生命周期

2.我们可以把每个小程序运行的过程，也概括为生命周期：

- 小程序的启动，表示生命周期的开始
- 小程序的关闭，表示生命周期的结束
- 中间小程序运行的过程，就是小程序的生命周期

## 4.1生命周期的分类

在小程序中，生命周期分为两类，分别是：

1. 应用生命周期
   - 特指小程序从启动 -> 运行 -> 销毁的过程
2. 页面生命周期
   - 特指小程序中，每个页面的加载 -> 渲染 -> 销毁的过程

其中，页面的生命周期范围较小，应用程序的生命周期范围较大，如图所示：

![](images\页面事件\2022-03-05_105317.png)

## 4.2什么是生命周期函数

1. 生命周期函数：是由小程序框架提供的内置函数，会伴随着生命周期，自动按次序执行。  

2. 生命周期函数的作用：允许程序员在特定的时间点，执行某些特定的操作。例如，页面刚加载的时候，可以在
   onLoad 生命周期函数中初始化页面的数据。

   **注意：生命周期强调的是时间段，生命周期函数强调的是时间点。**

## 4.3生命周期函数的分类

1. 小程序中的生命周期函数分为两类，分别是：
   - 应用的生命周期函数
     特指小程序从启动 -> 运行 -> 销毁期间依次调用的那些函数
   - 页面的生命周期函数
     特指小程序中，每个页面从加载 -> 渲染 ->  销毁期间依次调用的那些函数

## 4.4应用的生命周期函数

小程序的应用生命周期函数需要在 app.js 中进行声明，示例代码如下：

```js
// app.js
App({
  // 小程序初始化完成时，执行该函数，全局只触发一次，可以做一些初始化工作
  onLaunch(){},
  // 小程序启动，或从后台进入前台显示时触发
  onShow(){},
  // 小程序前台进入后台时触发
  onHide(){},
})
```

## 4.5页面的生命周期函数

小程序的页面生命周期函数需要在页面的 .js 文件中进行声明，示例代码如下：

```js
//页面的 .js
  onLoad: function (options) {},//生命周期函数--监听页面加载
  onReady: function () {},//生命周期函数--监听页面初次渲染完成
  onShow: function () {},// 生命周期函数--监听页面显示
  onHide: function () {},//生命周期函数--监听页面隐藏
  onUnload: function () {},// 生命周期函数--监听页面卸载
  onPullDownRefresh: function () {},// 页面相关事件处理函数--监听用户下拉动作
  onReachBottom: function () {},// 页面上拉触底事件的处理函数
```

# 5.WXS 脚本 

## 5.1什么是 wxs

WXS（WeiXin Script）是小程序独有的一套脚本语言，结合 WXML，可以构建出页面的结构。

## 5.2wxs 的应用场景

​	wxml 中无法调用在页面的 .js 中定义的函数，但是，wxml 中可以调用 wxs 中定义的函数。因此，小程序中
wxs 的典型应用场景就是“过滤器”。

## 5.3wxs 和 JavaScript 的关系

虽然 wxs 的语法类似于 JavaScript，但是 wxs 和 JavaScript 是完全不同的两种语言：

- wxs 有自己的数据类型
  number 数值类型、string 字符串类型、boolean 布尔类型、object 对象类型、
  function 函数类型、array 数组类型、	date 日期类型、	regexp 正则
- wxs 不支持类似于 ES6 及以上的语法形式
- 不支持：let、const、解构赋值、展开运算符、箭头函数、对象属性简写、etc...
- 支持：var 定义变量、普通 function 函数等类似于 ES5 的语法
-  wxs 遵循 CommonJS 规范
  module 对象
  require() 函数
  module.exports 对象

## 5.4基础语法

### 5.4.1定义内联的 wxs 脚本

wxs 代码可以编写在 wxml 文件中的 <wxs> 标签内，就像 Javascript 代码可以编写在 html 文件中的 <script>
标签内一样。
	wxml 文件中的每个 <wxs></wxs> 标签，必须提供 module 属性，用来指定当前 wxs 的模块名称，方便在
wxml 中访问模块中的成员：

```js
<view class="view-text-center"> {{m1.toUpper(userName)}}</view>
<wxs module="m1">
  module.exports.toUpper=function(str){
    return str.toUpperCase()
  }
</wxs>

data:{
    userName:"zhangsan"
}
```

### 5.4.2定义外联的 wxs 脚本

​	wxs 代码还可以编写在以 .wxs 为后缀名的文件内，就像 javascript 代码可以编写在以 .js 为后缀名的文件中  一样。示例代码如下：

```js
//tools.wxs文件
function toLoawerCase(str){
  return str.toLowerCase()
}
module.exports={
  toLoawerCase:toLoawerCase
}
```

在 wxml 中引入外联的 wxs 脚本时，必须为 <wxs> 标签添加 module 和 src 属性，其中：

- module 用来指定模块的名称src 用来指定要引入的脚本的路径，且必须是相对路径
  示例代码如下：

  ```html
  <!-- 外嵌wxs脚本 -->
  <view class="view-text-center">{{m2.toLoawerCase(country)}}</view>
  <wxs src='../../utils/tools.wxs' module="m2"></wxs>
  ```

  

## 5.6.WXS 的特点

### 5.6.1与 JavaScript 不同

​	**为了降低 wxs（WeiXin Script）的学习成本， wxs 语言在设计时借大量鉴了 JavaScript 的语法。但是本质上，wxs 和 JavaScript 是完全不同的两种语言！**

### 5.6.2不能作为组件的事件回调

​	wxs 典型的应用场景就是“过滤器”，经常配合 Mustache 语法进行使用，例如：

```html
<view class="view-text-center">{{m2.toLoawerCase(country)}}</view>
```

​	但是，在 wxs 中定义的函数不能作为组件的事件回调函数。例如，下面的用法是错误的：

```html
<button bindTip="m2.toLoawerCase">按钮</button>
```

### 5.6.3 隔离性

​	隔离性指的是 wxs 的运行环境和其他 JavaScript 代码是隔离的。体现在如下两方面：

1. wxs 不能调用 js 中定义的函数
2.  wxs 不能调用小程序提供的 API

### 5.6.3性能好

​	在 iOS 设备上，小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20  倍，在 android 设备上，二者的运行效率无差异

# 6.案例

# 7.总结

1.  能够知道如何实现页面之间的导航跳转
   - 声明式导航、编程式导航
   - enablePullDownRefresh、onPullDownRefresh
2. 能够知道如何实现下拉刷新效果
   - onReachBottomDistance、onReachBottom
3. 能够知道如何实现上拉加载更多效果
   - 应用生命周期函数：onLaunch, onShow, onHide
4. 能够知道小程序中常用的生命周期函数
   - 页面生命周期函数：onLoad, onShow, onReady, onHide, onUnload

# 四、**小程序** 基础加强

**学习目标：**

1. 能够创建并引用组件
2. 能够知道如何修改组件的样式隔离选项
3. 能够知道如何定义和使用数据监听器
4. 能够知道如何定义和使用纯数据字段
5. 能够知道实现组件父子通信有哪3种方式
6. 能够知道如何定义和使用behaviors

## 1.**自定义组件**

### 1.2**组件的创建与引用**

#### **1.2.1创建组件**

1. 项目的根目录中，鼠标右键，创建 components -> test 文件夹

2. 在新建的 components -> test 文件夹上，鼠标右键，点击“新建 Component”

3. 键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为 .js，.json， .wxml 和 .wxss

   **注意：为了保证目录结构的清晰，建议把不同的组件，存放到单独目录中**，例如：

   

![](images\基础加强\2022-03-07_085637.png)

#### 1.2.2**引用组件**

​	组件的引用方式分为“局部引用”和“全局引用”，顾名思义：

- 局部引用：组件只能在当前被引用的页面内使用
-  全局引用：组件可以在每个小程序页面中使用

#### **1.2.3** **局部引用组件**

在页面的 .json 配置文件中引用组件的方式，叫做“局部引用”。示例代码如下：

```json
{
  "usingComponents": { "test": "/components/test/test"},"
}
```

```html
<!--index.wxml-->
<!-- 组件的局部引用 -->
<test></test>
```

#### 1.2.4全局组价的引用

在 app.json 全局配置文件中引用组件的方式，叫做“全局引用”。示例代码如下：

```json
{
  "pages": [],
  "window": {},
  "tabBar": {
    "list": []
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json",
  "usingComponents": {"component-test2":"/components/component-test2/component-test2"}
}
```

#### 1.2.5**全局引用** **VS** **局部引用**

根据组件的使用频率和范围，来选择合适的引用方式：

- 如果某组件在多个页面中经常被用到，建议进行“全局引用”
-  如果某组件只在特定的页面中被用到，建议进行“局部引用”

1.2.6**组件和页面的区别**

从表面来看，组件和页面都是由 .js、.json、.wxml 和 .wxss 这四个文件组成的。但是，组件和页面的 .js 与.json 文件有明显的不同：

- 组件的 .json 文件中需要声明 "component": true 属性
- 组件的 .js 文件中调用的是 Component() 函数
-  组件的事件处理函数需要定义到 methods 节点中

## 2.**样式**

### 2.1**组件样式隔离**

默认情况下，自定义组件的样式只对当前组件生效，不会影响到组件之外的UI 结构，如图所示：

![](images\基础加强\2022-03-07_100415.png)

- 组件 A 的样式不会影响组件 C 的样式
- 组件 A 的样式不会影响小程序页面的样式
-  小程序页面的样式不会影响组件 A 和 C 的样式

**好处：**

1.  防止外界的样式影响组件内部的样式
2. 防止组件的样式破坏外界的样式

### 2.2**组件样式隔离的注意点**

- app.wxss 中的全局样式对组件无效， 只有 class 选择器会有样式隔离效果，id 选择器、属性选择器、标签选择器不受样式隔离的影响
- 建议：在组件和引用组件的页面中建议使用 class 选择器，**不要使用** id、属性、标签选择器！

### 2.3**修改组件的样式隔离选项**

​	默认情况下，自定义组件的样式隔离特性能够防止组件内外样式互相干扰的问题。但有时，我们希望在外界能 够控制组件内部的样式，此时，可以通过 **styleIsolation** 修改组件的样式隔离选项，用法如下：

```js
//在组价.js文件下新增
options:{
    styleIsolation:"isolated"
  },
  
  
///在组件.json文件下
{
  "component": true,
  "usingComponents": {},
  "styleIsolation":"isolated"
}
```

### 2.4**styleIsolation** **的可选值**

|    可选值    | 默认值 | 描述                                                         |
| :----------: | :----: | ------------------------------------------------------------ |
|   isolated   |   是   | 表示启用样式隔离，在自定义组件内外，使用  class 指定的样式将不会相互影响 |
| apply-shared |   否   | 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面 |
| apply-shared |   否   | 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也<br/>会影响页面和其他设置了 apply-shared 或 shared 的自定义组件 |

## 3.**数据、方法和属性**

### 3.1**data** **数据**

在小程序组件中，**用于组件模板渲染的私有数据**，需要定义到 data 节点中，示例如下

```js
Component({
  /**
   * 组件的初始数据
   */
  data: {
	count：0
  },

})
```

### 3.2**methods** **方法**

在小程序组件中，事件处理函数和自定义方法需要定义到 methods 节点中，示例代码如下：

```js
//布局
<button bindtap="countAdd" type="warn"> count+1</button>

Component({
methods: {//组件的方法列表[包含事件处理函数和自定义方法]
    countAdd(){//事件处理函数
      this.setData({
        count:this.data.count+1
      })
      this._showCount()//通过this直接调用自定义方法
    },
    _showCount(){//自定义方法一般建议以_开头
      wx.showToast({
        title:"count值为："+this.data.count,
        icon:'none'
      })
    }
  }
})
```

### 3.3**properties** **属性**

在小程序组件中，properties 是组件的对外属性，**用来接收外界传递到组件中的数据**，示例代码如下：

```js
// components/component-test2/component-test2.js

//使用组件
<component-test2  max="10"></component-test2>

Component({
  properties: {
    max: { //完整定义属性方式[当需要指定属性默认值时，建议使用此方式]
      type: Number, //属性值类型
      value: 10 //默认属性值
    },
    max: Number //简化定义属性方式[不指定属性默认值时，可以使用简化方式]
  },
})
```

### 3.4 **data** **和** **properties** **的区别**

在小程序的组件中，properties 属性和 data 数据的用法相同，它们都是可读可写的，只不过：

-  data 更倾向于存储组件的私有数据
-  properties 更倾向于存储外界传递到组件中的数据

```js
//使用组件
<component-test2  max="10"></component-test2>

Component({
  properties: {
    max: { //完整定义属性方式[当需要指定属性默认值时，建议使用此方式]
      type: Number, //属性值类型
      value: 10 //默认属性值
    },
    max: Number //简化定义属性方式[不指定属性默认值时，可以使用简化方式]
  },
  showIfo(){
      console.log(this.data);
      console.log(this.properties);
      console.log(this.data===this.properties);
    }
})
```

### 3.5**使用** **setData** **修改** **properties** **的值**

```js

    //使用组件
<component-test2  max="10"></component-test2>

Component({
  properties: {
    max: { //完整定义属性方式[当需要指定属性默认值时，建议使用此方式]
      type: Number, //属性值类型
      value: 10 //默认属性值
    },
    max: Number //简化定义属性方式[不指定属性默认值时，可以使用简化方式]
  },
  methods: { //组件的方法列表[包含事件处理函数和自定义方法]
    countAdd() { //事件处理函数
      if(this.data.count>this.properties.max){
        wx.showToast({
          title: '大于Max'+this.properties.max,
          icon:"none"
        })
      }else{
        this.setData({
          count: this.data.count + 1
        })
        this._showCount() //通过this直接调用自定义方法
        this.showIfo()
      }
      this.setData({
        max:this.properties.max+1
      })
    },
})
```

## 4.**数据监听器**

### 4.1**什么是数据监听器**

数据监听器用于监听和响应任何属性和数据字段的变化，从而执行特定的操作。它的作用类似于 vue 中的watch 侦听器。在小程序组件中，数据监听器的基本语法格式如下：

```js
 observers: {
    'numberA, numberB': function(numberA, numberB) {
      // 在 numberA 或者 numberB 被设置时，执行这个函数
      this.setData({
        sum: numberA + numberB
      })
    }
  }
})
```

#### 4.1.1**数据监听器的基本用法**

组件的 UI 结构如下：

```html
<view class="view-text-center">sum:{{sum}}={{num1}}+{{num2}}</view>
<button type="primary" bindtap="addnum1">num1+1</button>
<button type="warn" bindtap="addnum2">num2+1</button>
```

组件的 .js 文件代码如下：

```js
// components/component-test2/component-test2.js
Component({

  /**
   * 组件的初始数据
   */
  data: {
    sum:0,
    num1:0,
    num2:0
  },

  /**
   * 组件的方法列表
   */
  methods: { //组件的方法列表[包含事件处理函数和自定义方法]
    // num1加1方法
    addnum1(){
      this.setData({
        num1:this.data.num1+1
      })
    },
    // num2加1方法
    addnum2(){
      this.setData({
        num2:this.data.num2+1
      })
    }
  },
  observers:{//数据监听节点
    "num1, num2":function(num1,num2){//监听num1和num2数据变化
      this.setData({
        sum:num1+num2 //通过监听器来自动计算sum
      })
    }
  }
})

```

#### **4.1.2** **监听对象属性的变化**

​	数据监听器支持**监听对象中单个或多个属性的变化**，示例语法如下：

```js
Component( {
    observers: {
    '对象.属性A,对象.属性B': function(属性A的新值，属性B的新值) {
    //触发此监听器的3种情况:
    // [为属性A赋值]使用setData 设置this.data.对象.属性A时触发
    // [为属性B赋值]使用setData 设置this.data.对象.属性B时触发
    // [直接为对象赋值]使用setData 设置this.data.对象 时触发
    // do something...
		}
 	}
 })

```

#### 4.1.3**数据监听器** **-** **案例**

- **案例效果：**

![](L:\学习笔记\study-notes\微信小程序\images\基础加强\2022-03-07_140535.png)

- **渲染** **UI** **结构**

```
<view style="background-color: rgba({{fullColor}});" class="bgcBox">颜色值:{{fullColor}}</view>
<view class="view-text-center">
  <button size="mini" type="warn" bindtap="changeR">R</button>
  <button size="mini" type="primary" bindtap="changeG">G</button>
  <button size="mini" type="default" bindtap="changeB">B</button>
</view>

.bgcBox{
 line-height: 200rpx;
 font-size: 24rpx;
 color: white;
 text-shadow:0 0 2rpx black ;
 text-align: center;
 margin: 0 20rpx;
 border-radius: 8rpx;
}
```

- **定义 data数据**

```js
data: {
   rgb:{
    r:0,
    g:0,
    b:0
   },
   fullColor:'0,0,0'
  },
```

- **定义** **button** **的事件处理函数**

```js
methods: {
    changeR(){
      this.setData({
        'rgb.r':this.data.rgb.r+5>255?255:this.data.rgb.r+5
      })
      // console.log(this.data.rgb);
    },
    changeG(){
      this.setData({
        'rgb.g':this.data.rgb.g+5>255?255:this.data.rgb.g+5
      })
      // console.log(this.data.rgb);
    },
    changeB(){
      this.setData({
        'rgb.b':this.data.rgb.b+5>255?255:this.data.rgb.b+5
      })
      // console.log(this.data.rgb);
    }
  },
```

- **监听对象中指定属性的变化**

```js
observers:{
    "rgb.r,rgb.g,rgb.b":function(r,g,b){
      this.setData({
        fullColor:`${r},${g},${b}`
      })
    }
  }
```

## 5.**纯数据字段**

- 概念：纯数据字段指的是那些不用于界面渲染的 data 字段。
- 应用场景：例如有些情况下，某些 data 中的字段既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。带有这种特性的 data 字段适合被设置为纯数据字段。
- 好处：纯数据字段有助于提升页面更新的性能。

### 5.1使用规则

​	在 Component 构造器的 options 节点中，指定 pureDataPattern 为一个正则表达式，字段名符合这个正则 表达式的字段将成为纯数据字段，示例代码如下：

```js
Component({
    options: {
    	//指定所有_ 开头的数据字段为纯数据字段
        pureDataPattern: /^ /
    },
    data: {
        a: true ,
        //普通数据字段
        _ b: true, //纯数据字段
    }
})

```

### 5.2**使用纯数据字段改造数据监听器案例**

```js
 data: {
   _rgb:{
    r:0,
    g:0,
    b:0
   },
   fullColor:'0,0,0'
  },
```

## 6.**组件的生命周期**

小程序组件可用的全部生命周期如下表所示：

| **生命周期函数** |   **参数**    | **描述说明**                             |
| :--------------: | :-----------: | ---------------------------------------- |
|     created      |      无       | 在组件实例刚刚被创建时执行               |
|     attached     |      无       | 在组件实例进入页面节点树时执行           |
|      ready       |      无       | 在组件在视图层布局完成后执行             |
|      moved       |      无       | 在组件实例被移动到节点树另一个位置时执行 |
|     detached     |      无       | 在组件实例被从页面节点树移除时执行       |
|      error       | Object  Error | 每当组件方法抛出错误时执行               |

### 6.1组件主要的生命周期函数

在小程序组件中，最重要的生命周期函数有 3 个，分别是 created、**attached**、detached。它们各自的特点 如下：

1.  组件实例刚被创建好的时候，created 生命周期函数会被触发
   - 此时还不能调用 setData
   - 通常在这个生命周期函数中，只应该用于给组件的 this 添加一些自定义的属性字段

2. 在组件完全初始化完毕、进入页面节点树后， attached 生命周期函数会被触发
   -  此时， this.data 已被初始化完毕
   - 这个生命周期很有用，绝大多数初始化的工作可以在这个时机进行（例如发请求获取初始数据）

3. 在组件离开页面节点树后， detached 生命周期函数会被触发
   - 退出一个页面时，会触发页面内每个自定义组件的 detached 生命周期函数
   - 此时适合做一些清理性质的工作

### 6.2lifetimes节点

​	在小程序组件中，生命周期函数可以直接定义在 Component 构造器的第一级参数中，可以在 lifetimes 字段 内进行声明（这是推荐的方式，其优先级最高）。示例代码如下：

```js
// components/example/example.js
Component({
  lifetimes: {
    //推荐用法
    attached() {},
    datached() {},
  },
  //老式用法
  attached() {},
  datached() {}
})
```

## 7.**组件所在页面的生命周期**

​	有时，自定义组件的行为依赖于页面状态的变化，此时就需要用到组件所在页面的生命周期。 例如：每当触发页面的 show 生命周期函数的时候，我们希望能够重新生成一个随机的 RGB 颜色值。 在自定义组件中，组件所在页面的生命周期函数有如下 3 个，分别是：

| **生命周期函数** |   **参数**   | **描述**                     |
| :--------------: | :----------: | ---------------------------- |
|       show       |      无      | 组件所在的页面被展示时执行   |
|       hide       |      无      | 组件所在的页面被隐藏时执行   |
|      resize      | Object  Size | 组件所在的页面尺寸变化时执行 |

### 7.1**pageLifetimes** **节点**

```js
// components/example/example.js
Component({
  pageLifetimes: {
    show: function () {}, //页面被展示
    hide: function () {}, //页面被隐藏
    resize: function () {} //页面尺寸变化
  }
})
```

### 7.2**生成随机的** **RGB** **颜色值**

```js
Component({
//随机生成颜色
_randomColor(){
    this.setData({
      _rgb:{
        r:Math.floor(Math.random()*256),
        g:Math.floor(Math.random()*256),
        b:Math.floor(Math.random()*256)
      }
    })
},
pageLifetimes: {
    show: function () {//页面被展示
      this._randomColor()
    }, 
    hide: function () {}, //页面被隐藏
    resize: function () {} //页面尺寸变化
  }
)}
```

## 8.**插槽**

### 8.1**什么是插槽**

在自定义组件的 wxml 结构中，可以提供一个 **<slot>** 节点（插槽），用于承载组件使用者提供的 wxml 结构。

![](images\基础加强\2022-03-07_154727.png)

### 8.2单个插槽

在小程序中，默认每个自定义组件中只允许使用一个 <slot> 进行占位，这种个数上的限制叫做单个插槽。

```html
<!--components/slot/slot.wxml-->
<view class="tilte">slot单个插槽</view>
<slot></slot>

<!-- 插槽 -->
<slot-example>
  <view>单个插槽</view>
</slot-example>
```

### 8.3启用多个插槽

​	在小程序的自定义组件中，需要使用多 <slot> 插槽时，可以在组件的 .js 文件中，通过如下方式进行启用。 示例代码如下：

```html
//插槽定义
<view class="view-text-center">
  <slot name="slot1"></slot>
</view>
<view class="view-text-center">~~~~~~~~~~~~~~</view>
<view class="view-text-center">
  <slot name="slot2"></slot>
</view>
//使用插槽
<slot-example>
  <view slot="slot1">多个插槽</view>
  <view slot="slot2">多个插槽</view>
</slot-example>
```

## 9.**父子组件之间的通信**

### 9.1**父子组件之间通信的** **3** **种方式**

1. 属性绑定
   - 用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容的数据
2. 事件绑定
   - 用于子组件向父组件传递数据，可以传递任意数据
3.  获取组件实例
   -  父组件还可以通过 this.selectComponent() 获取子组件实例对象
   -  这样就可以直接访问子组件的任意数据和方法

### 9.1.1**属性绑定**

- 属性绑定用于实现父向子传值，而且只能传递普通类型的数据，无法将方法传递给子组件。父组件的示例代码 如下：

```js
<componets-properties number="{{number}}"></componets-properties>
<view class="view-text-center">~~~~~~~~~~~~~~~~~</view>
<view class="view-text-center">父组件中的number：{{number}}</view>

//父组件data节点
data:{
	number:10
}
```

- 子组件在 properties 节点中声明对应的属性并使用。示例代码如下：

```js
<view class="view-text-center">子组件接收的number：{{number}}</view>

//子组件的properties节点
properties: {
    number:Number
  },
```

### 9.1.2事件绑定

事件绑定用于实现子向父传值，可以传递任何类型的数据。使用步骤如下：

1. 在父组件的 js 中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件
2.  在父组件的 wxml 中，通过自定义事件的形式，将步骤 1 中定义的函数引用，传递给子组件
3. 在子组件的 js 中，通过调用 this.triggerEvent('自定义事件名称', { /* 参数对象 */ }) ，将数据发送到父组件
4.  在父组件的 js 中，通过 e.detail 获取到子组件传递过来的数据

**步骤1：**在父组件的 js 中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件。

```js
 asycNumber(){
   console.log("asycNumber");
  },
```

**步骤2**：在父组件的 wxml 中，通过自定义事件的形式，将步骤 1 中定义的函数引用，传递给子组件。

```html
<!-- 使用bind：自定义事件名 (推荐结构清晰) -->
<componets-properties number="{{number}}" bind:asyc="asycNumber"></componets-properties>
<!-- 使用bind后面直接加上自定义事件名 -->
<componets-properties number="{{number}}" bindasyc="asycNumber"></componets-properties>
```

**步骤3**：在子组件的 js 中，通过调用 this.triggerEvent(‘自定义事件名称’, { /* 参数对象 */ }) ，将数据发送到父组件。

```js
<view class="view-text-center">子组件接收的number：{{number}}</view>

methods: {
    addNumber(){
      this.setData({
        number:this.data.number+1
      }) 
      this.triggerEvent('asyc',{value:99})
    }
  }
```

**步骤4**：在父组件的 js 中，通过 e.detail 获取到子组件传递过来的数据

```js
 asycNumber(e){
    // console.log("asycNumber",e);
    this.setData({
      number:this.data.number+e.detail.value
    })
  },
```

### 9.1.3**获取组件实例**

​	可在父组件里调用 this.selectComponent("id或class选择器") ，获取子组件的实例对象，从而直接访问子组 件的任意数据和方法。调用时需要传入一个选择器，例如 this.selectComponent(".my-component")。

```js
//ui结构
<componets-properties number="{{number}}" bindasyc="asycNumber" class="customA" id="CA"></componets-properties>
<button type="warn" bindtap="getChild">获取子组件实例</button>

 getChild(){
    // const child=this.selectComponent('.customA')[0]
    const child=this.selectComponent("#CA")
    console.log(child);
    child.setData({
      number:child.properties.number+5
    })
    child.addNumber()
  },
```

**注意：this.selectComponent()只能传id选择器和class选择器不能传递标签选择器**

## 10.**behaviors**

### 10.1什么是behaviors

behaviors 是小程序中，用于实现组件间代码共享的特性，类似于 Vue.js 中的 “mixins”。

![](images\基础加强\2022-03-07_192220.png)

### 10.2**behaviors** **的工作方式**

​	每个 behavior 可以包含一组**属性、数据、生命周期函数和方法**。组件引用它时，它的属性、数据和方法会被 合并到组件中。

每个组件**可以引用多个 behavior**，behavior 也可以引用其它 behavior。

### 10.3 **创建** **behavior**

- 调用 Behavior(Object object) 方法即可创建一个共享的 behavior 实例对象，供所有的组件使用：

```js
// 1.使用require() 导入需要的自定义behavior 模块
 const myBehavior = require(" ../ ../behaviors/my-behavior")

 Component({
 // 2.将导入的behavior实例对象，挂载到behaviors数组节点中，即可生效

behaviors: [myBehavior],
 // 组件的其它节点...
})
```

### 10.4**导入并使用** **behavior**

​	在组件中，使用 require() 方法导入需要的 behavior，挂载后即可访问 behavior 中的数据或方法，示例代码 如下：

```js
 // 1.使用require() 导入需要的自定义behavior 模块
 const myBehavior = require(" ../ ../behaviors/my-behavior")

 Component({
// 2.将导入的behavior实例对象，挂载到behaviors数组节点中，即可生效

behaviors: [myBehavior],
// 组件的其它节点...
 })
```

### 10.5**behavior** **中所有可用的节点**

| **可用的节点** | **类型**      | **是否必填** | **描述**            |
| -------------- | ------------- | ------------ | ------------------- |
| properties     | Object  Map   | 否           | 同组件的属性        |
| data           | Object        | 否           | 同组件的数据        |
| methods        | Object        | 否           | 同自定义组件的方法  |
| behaviors      | String  Array | 否           | 引入其它的 behavior |
| created        | Function      | 否           | 生命周期函数        |
| attached       | Function      | 否           | 生命周期函数        |
| ready          | Function      | 否           | 生命周期函数        |
| moved          | Function      | 否           | 生命周期函数        |
| detached       | Function      | 否           | 生命周期函数        |

### 10.6同名字段的覆盖和组合规则（了解）

组件和它引用的 behavior 中可以包含同名的字段，此时可以参考如下 3 种同名时的处理规则：

-  同名的数据字段 (data)
-  同名的属性 (properties) 或方法 (methods)
- 同名的生命周期函数

**关于详细的覆盖和组合规则，大家可以参考微信小程序官方文档给出的说明：**

https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html

## 11.总结

1. 能够创建并引用组件 
   - 全局引用、局部引用、usingComponents 

2. 能够知道如何修改组件的样式隔离选项 
   -  options -> styleIsolation（ isolated, apply-shared, shared） 

3. 能够知道如何定义和使用数据监听器 
   - observers 
4. 能够知道如何定义和使用纯数据字段 
   - options -> pureDataPattern 
5. 能够知道实现组件父子通信有哪3种方式 
   - 属性绑定、事件绑定、this.selectComponent(' id或class选择器') 
6. 能够知道如何定义和使用behaviors 
   - 调用 Behavior() 构造器方法

# 五、**使用 npm 包** 

## 1.**小程序对 npm 的支持与限制**

目前，小程序中已经支持使用 npm 安装第三方包，从而来提高小程序的开发效率。但是，在小程序中使用 

npm 包有如下 3 个限制： 

1.  不支持依赖于 Node.js 内置库的包 
2.  不支持依赖于浏览器内置对象的包 
3.  不支持依赖于 C++ 插件的包 

**总结：虽然 npm 上的包有千千万，但是能供小程序使用的包却“为数不多”。**

## 2.**Vant Weapp**

### 2.1**什么是 Vant Weapp**

Vant Weapp 是有赞前端团队开源的一套小程序 UI 组件库，助力开发者快速搭建小程序应用。它所使用的是 

MIT 开源许可协议，对商业使用比较友好。 

官方文档地址 https://youzan.github.io/vant-weapp 

扫描下方的小程序二维码，体验组件库示例：

![](J:\学习笔记\study-notes\微信小程序\images\npm包\2022-03-07_204017.png)

